/**********************************************************************
*  Copyright (c) 2008-2016, Alliance for Sustainable Energy.
*  All rights reserved.
*
*  This library is free software; you can redistribute it and/or
*  modify it under the terms of the GNU Lesser General Public
*  License as published by the Free Software Foundation; either
*  version 2.1 of the License, or (at your option) any later version.
*
*  This library is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*  Lesser General Public License for more details.
*
*  You should have received a copy of the GNU Lesser General Public
*  License along with this library; if not, write to the Free Software
*  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
**********************************************************************/

#include <utilities/core/ApplicationPathHelpers.hpp>
#include <utilities/core/PathHelpers.hpp>

#include <OpenStudio.hxx>

#include <QCoreApplication>
#include <sstream>
#include <boost/algorithm/string/case_conv.hpp>
#include <iostream>

#ifdef Q_OS_WIN
#include <Windows.h>
#else
#include <dlfcn.h>
#endif


  bool pathBeginsWith(const openstudio::path &t_shorter, const openstudio::path &t_longer)
  {
    openstudio::path::const_iterator begin1 = t_shorter.begin();
    openstudio::path::const_iterator end1 = t_shorter.end();

    openstudio::path::const_iterator begin2 = t_longer.begin();
    openstudio::path::const_iterator end2 = t_longer.end();

    if (std::distance(begin1, end1) > std::distance(begin2, end2))
    {
      return false; // the run dir has fewer elements than the build dir - cannot be running from builddir
    }

    // if the rundir begins with the builddir, we know it's running from the builddir
    return std::equal(begin1, end1, begin2);

  }


namespace openstudio {

  openstudio::path getApplicationSourceDirectory() {
    return openstudio::toPath("${CMAKE_SOURCE_DIR}");
  }

  openstudio::path getApplicationBuildDirectory() {
    return openstudio::toPath("${CMAKE_BINARY_DIR}");
  }

  openstudio::path getApplicationInstallDirectory() {
    return openstudio::toPath("${CMAKE_INSTALL_PREFIX}");
  }

  openstudio::path getSharedResourcesPath()
  {
    if (applicationIsRunningFromBuildDirectory())
    {
      return getApplicationSourceDirectory() / openstudio::toPath("resources");
    }
    else
    {
      openstudio::path candidate;
#if defined(Q_OS_MAC)
      candidate = getApplicationRunDirectory().parent_path().parent_path().parent_path() / openstudio::toPath("sharedresources");
#elif defined(Q_OS_LINUX)
      candidate = getApplicationRunDirectory().parent_path() / openstudio::toPath("share/openstudio-" + openStudioVersion() + "");
#else
      candidate = getApplicationRunDirectory().parent_path() / openstudio::toPath("share/openstudio");
#endif
      // revert to build directory location for regression tests and other external projects
      // that link to a developer build of OpenStudio
      if (!boost::filesystem::exists(candidate)) {
        openstudio::path alternate = getApplicationSourceDirectory() / openstudio::toPath("resources");
        if (boost::filesystem::exists(alternate)) {
          candidate = alternate;
        }
      }
      return candidate;
    }
  }

  openstudio::path getOpenStudioAWSRubyPath()
  {
#ifdef Q_OS_WIN
    return getOpenStudioEmbeddedRubyPath();
#else
    openstudio::path expectedPath = openstudio::toPath("${AWS_RUBY_DESTINATION}")/openstudio::toPath("${AWS_RUBY_PATH}");
    openstudio::path buildPath = getApplicationBuildDirectory() / openstudio::toPath("${AWS_RUBY_PATH}");

    if (applicationIsRunningFromBuildDirectory())
    {
      return buildPath;
    }

    openstudio::path candidate;
#if defined(Q_OS_MAC)
    candidate = getApplicationRunDirectory().parent_path().parent_path().parent_path() / expectedPath;
#else
    candidate = getApplicationRunDirectory().parent_path() / expectedPath;
#endif
    //std::cout << "candidate: " << openstudio::toString(candidate) << std::endl;
    //std::cout << "expectedPath: " << openstudio::toString(expectedPath) << std::endl;
    //std::cout << "buildPath: " << openstudio::toString(buildPath) << std::endl;
    // revert to build directory location for regression tests and other external projects
    // that link to a developer build of OpenStudio
    if (!boost::filesystem::exists(candidate)) {
      if (boost::filesystem::exists(buildPath)) {
        return buildPath;
      }
    }

    return candidate;
#endif
  }


  openstudio::path getApplicationRunDirectory() {
#ifdef Q_OS_WIN
    TCHAR path[2048];
    int size = GetModuleFileName(GetModuleHandle("openstudio_utilities.dll"), path, sizeof(path)-1);

    std::string dllstr(path, size);
    openstudio::path dllpath = openstudio::toPath(dllstr);
    openstudio::path rundir = dllpath.parent_path();

    if (openstudio::toString(rundir.filename()) == "openstudio" &&
        openstudio::toString(rundir.parent_path().filename()) == "Ruby")
    {
      // It looks like our DLL was loaded from the installed ruby dir, so we
      // are going to reset to relative bin dir
      rundir = rundir.parent_path().parent_path() / openstudio::toPath("bin");
    }

    return completeAndNormalize(rundir);
#else
    Dl_info rInfo;
    memset( &rInfo, 0, sizeof(rInfo) );
    if ( !dladdr((void*)(&getApplicationRunDirectory), &rInfo)  || !rInfo.dli_fname ) {
      return completeAndNormalize(openstudio::toPath(QCoreApplication::applicationDirPath()));
    }


    std::string dllpath(rInfo.dli_fname);

//    std::cout << "dladdr: " << dllpath << std::endl;

    openstudio::path rundir = openstudio::toPath(dllpath).parent_path();

    // Let's see if this is a link that we should expand
    std::vector<char> buf(2048);
    size_t pathlen = readlink(openstudio::toString(rundir).c_str(), &buf.front(), buf.size());
    if (pathlen > 0 && pathlen < buf.size())
    {
      rundir = openstudio::toPath(std::string(&buf.front(), pathlen));
    }

#ifdef Q_OS_MAC
    if (pathBeginsWith(getApplicationBuildDirectory(), rundir))
    {
      // we are definitely running from the build dir, let's reset the path to a known place
      rundir = getApplicationBuildDirectory() / openstudio::toPath("Products/OpenStudio.app/Contents/MacOS");
    } else if (rundir.filename() != "MacOS" && rundir.filename() != "openstudio") {
      // We are not running from a regular run directory, try Qt method instead
      openstudio::path p = openstudio::toPath(QCoreApplication::applicationDirPath());
      if (!p.empty())
      {
        rundir = p;
      }
    }

    if (openstudio::toString(rundir.filename()) == "openstudio" &&
        openstudio::toString(rundir.parent_path().filename()) == "Ruby")
    {
      // It looks like our DLL was loaded from the installed ruby dir, so we
      // are going to reset to a known application path
      rundir = rundir.parent_path().parent_path() / openstudio::toPath("OpenStudio.app/Contents/MacOS");
    }

    if (openstudio::toString(rundir.filename()) == "openstudio" &&
        openstudio::toString(rundir.parent_path().filename()) == "node")
    {
      // It looks like our DLL was loaded from the installed node dir, so we
      // are going to reset to a known application path
      rundir = rundir.parent_path().parent_path() / openstudio::toPath("OpenStudio.app/Contents/MacOS");
    }
#endif

    std::string filename = openstudio::toString(rundir.filename());
    std::string parentfilename = openstudio::toString(rundir.parent_path().filename());

    if (filename == "lib" && boost::filesystem::exists(rundir.parent_path() / openstudio::toPath("bin")))
    {
      // if we're currently in the lib dir, pop up to the bin dir,
      // this will maintain consistency with the fallback qt function used above
      // and previously
      rundir = rundir.parent_path() / openstudio::toPath("bin");
    }

    if (filename == "Node-install" || filename == "Ruby-install")
    {
      rundir = rundir.parent_path().parent_path().parent_path() / openstudio::toPath("OSCore-prefix/src/OSCore-build/Products");
    }

    if (parentfilename == "Node-install" || parentfilename == "Ruby-install")
    {
      rundir = rundir.parent_path().parent_path().parent_path().parent_path() / openstudio::toPath("OSCore-prefix/src/OSCore-build/Products");
    }

//    std::cout << "Rundir: " << openstudio::toString(rundir) << std::endl;


    return completeAndNormalize(rundir);
#endif
  }

  openstudio::path getOpenStudioRubyPath() {
    if (applicationIsRunningFromBuildDirectory())
    {
#if defined(Q_OS_LINUX) || defined(Q_OS_MAC)
      return getApplicationBuildDirectory() / openstudio::toPath("Products/ruby");
#else
      openstudio::path rundir = getApplicationRunDirectory();
      openstudio::path::const_iterator buildname = rundir.end();
      --buildname; // Last path name should be build name;
      return getApplicationBuildDirectory() / openstudio::toPath("Products/ruby") / *buildname;
#endif
    } else {
#ifdef Q_OS_LINUX
      return getApplicationRunDirectory().parent_path() / openstudio::toPath("${RUBY_MODULE_ARCH_DIR}");
#elif defined(Q_OS_MAC)
      return getApplicationRunDirectory(); // get the fixed up ones in the application path
#else
      return getApplicationRunDirectory().parent_path() / openstudio::toPath("Ruby/openstudio");
#endif
    }
  }

  openstudio::path getOpenStudioRubyIncludePath() {
    if (applicationIsRunningFromBuildDirectory())
    {
#if defined(Q_OS_LINUX) || defined(Q_OS_MAC)
      return getApplicationBuildDirectory() / openstudio::toPath("ruby");
#else
      openstudio::path rundir = getApplicationRunDirectory();
      openstudio::path::const_iterator buildname = rundir.end();
      --buildname; // Last path name should be build name;
      return getApplicationBuildDirectory() / openstudio::toPath("ruby") / *buildname;
#endif
    } else {
      // DLM: do not rely on installer adding this to the ruby path
      // installer makes openstudio readily available
      //return openstudio::path();
      return getOpenStudioRubyScriptsPath();
    }
  }

  std::vector<openstudio::path> getOpenStudioBareRubyPaths()
  {
    // mirrors \openstudiocore\ruby\openstudio.rb
    std::vector<openstudio::path> filenames;
    filenames.push_back(openstudio::toPath("openstudioutilitiescore"));
    filenames.push_back(openstudio::toPath("openstudioutilitiestime"));
    filenames.push_back(openstudio::toPath("openstudioutilitiesdata"));
    filenames.push_back(openstudio::toPath("openstudioutilitiesplot"));
    filenames.push_back(openstudio::toPath("openstudioutilitiesgeometry"));
    filenames.push_back(openstudio::toPath("openstudioutilitiessql"));
    filenames.push_back(openstudio::toPath("openstudioutilitiesbcl"));
    filenames.push_back(openstudio::toPath("openstudioutilitiescloud"));
    filenames.push_back(openstudio::toPath("openstudioutilitiesunits"));
    filenames.push_back(openstudio::toPath("openstudioutilitiesidd"));
    filenames.push_back(openstudio::toPath("openstudioutilitiesidf"));
    filenames.push_back(openstudio::toPath("openstudioutilitiesfiletypes"));
    filenames.push_back(openstudio::toPath("openstudioutilities"));
    filenames.push_back(openstudio::toPath("openstudiomodel"));
    filenames.push_back(openstudio::toPath("openstudiomodelcore"));
    filenames.push_back(openstudio::toPath("openstudiomodelsimulation"));
    filenames.push_back(openstudio::toPath("openstudiomodelresources"));
    filenames.push_back(openstudio::toPath("openstudiomodelgeometry"));
    filenames.push_back(openstudio::toPath("openstudiomodelhvac"));
    filenames.push_back(openstudio::toPath("openstudiomodelrefrigeration"));
    filenames.push_back(openstudio::toPath("openstudiomodelgenerators"));
    filenames.push_back(openstudio::toPath("openstudioenergyplus"));
    filenames.push_back(openstudio::toPath("openstudioradiance"));
    filenames.push_back(openstudio::toPath("openstudiogbxml"));
    filenames.push_back(openstudio::toPath("openstudioairflow"));
    filenames.push_back(openstudio::toPath("openstudioosversion"));
    filenames.push_back(openstudio::toPath("openstudioruleset"));
    filenames.push_back(openstudio::toPath("openstudiorunmanager"));
    filenames.push_back(openstudio::toPath("openstudioproject"));
    filenames.push_back(openstudio::toPath("openstudioanalysisdriver"));
    filenames.push_back(openstudio::toPath("openstudiomodeleditor"));
    filenames.push_back(openstudio::toPath("openstudioanalysis"));
    filenames.push_back(openstudio::toPath("openstudiolib"));
    filenames.push_back(openstudio::toPath("openstudioisomodel"));
    filenames.push_back(openstudio::toPath("openstudiosdd"));

    return filenames;
  }

  std::vector<openstudio::path> getOpenStudioRubyPaths()
  {
    std::vector<openstudio::path> filenames = getOpenStudioBareRubyPaths();
    openstudio::path rubylibbasepath = getOpenStudioRubyPath();

    for (std::vector<openstudio::path>::iterator itr = filenames.begin();
         itr != filenames.end();
         ++itr)
    {
      *itr = rubylibbasepath / *itr;
    }

    return filenames;
  }

  bool applicationIsRunningFromBuildDirectory()
  {
#ifdef Q_OS_WIN
    openstudio::path buildDir = openstudio::toPath(boost::algorithm::to_upper_copy(openstudio::toString(getApplicationBuildDirectory())));
    openstudio::path runDir = openstudio::toPath(boost::algorithm::to_upper_copy(openstudio::toString(getApplicationRunDirectory())));
#else
    openstudio::path buildDir = getApplicationBuildDirectory();
    openstudio::path runDir = getApplicationRunDirectory();
#endif

    return pathBeginsWith(buildDir, runDir);
  }


openstudio::path getApplicationOutputDirectory(const std::string& outdir) {
  openstudio::path result(openstudio::toPath(outdir));
  std::stringstream ss, tss;

  // turn relative path into absolute path
  result = boost::filesystem::system_complete(result);
  std::string dirStr = openstudio::toString(result);
  // create string used in error messages
  if (dirStr != outdir) { tss << " (" << dirStr << ")"; }

  // result cannot be a file
  if (boost::filesystem::is_regular_file(result)) {
    ss << "Invalid outdir, " << outdir << tss.str()
       << ", is a file instead of a directory with a valid parent_path.";
    throw std::runtime_error(ss.str().c_str());
  }

  // if result is not yet a directory
  if (!boost::filesystem::is_directory(result)) {
    // parent path must be an existing directory
    if (!boost::filesystem::is_directory(result.parent_path())) {
      ss << "Invalid outdir, " << outdir << tss.str()
         << ", has a parent_path, " << openstudio::toString(result.parent_path())
         << ", that is either invalid, or corresponds to a non-existent directory.";
      throw std::runtime_error(ss.str().c_str());
    }
    // make the output directory, if possible
    std::cout << "Creating output directory " << dirStr << "." << std::endl;
    bool ok = boost::filesystem::create_directory(result);
    if (!ok) {
      ss << "Unable to create outdir " << outdir << tss.str() << ".";
      throw std::runtime_error(ss.str().c_str());
    }
  }

  std::cout << std::endl << "All output will be directed to " << dirStr << "."
            << std::endl << std::endl;
  return result;
}

openstudio::path getOpenStudioRubyScriptsPath() {
  if (applicationIsRunningFromBuildDirectory())
  {
    return getApplicationSourceDirectory() / openstudio::toPath("ruby");
  } else {
#ifdef Q_OS_LINUX
    return getApplicationInstallDirectory() / openstudio::toPath("share/openstudio-" + openStudioVersion() + "/Ruby");
#elif defined(Q_OS_MAC)
    return getApplicationRunDirectory().parent_path().parent_path().parent_path() / openstudio::toPath("Ruby");
#else
    return getApplicationRunDirectory().parent_path() / openstudio::toPath("Ruby");
#endif
  }
}

openstudio::path getOpenStudioEmbeddedRubyPath() {
#ifdef Q_OS_WIN
  if (applicationIsRunningFromBuildDirectory()) {
    return getApplicationBuildDirectory().parent_path().parent_path().parent_path() / openstudio::toPath("Ruby-prefix/src/Ruby");
  } else {
    return getApplicationRunDirectory().parent_path() / openstudio::toPath("ruby-install/ruby");
  }
#else
  return openstudio::path();
#endif
}

openstudio::path getEnergyPlusDirectory() {
  openstudio::path cmakeEnergyPlusPath = openstudio::toPath("${ENERGYPLUS_EXE}");
  openstudio::path cmakeEnergyPlusDirectory = cmakeEnergyPlusPath.parent_path();
  openstudio::path energyPlusDirectoryName = cmakeEnergyPlusDirectory.filename();

  if (applicationIsRunningFromBuildDirectory())
  {
    return cmakeEnergyPlusDirectory;
  } else {
#ifdef Q_OS_LINUX
    return getApplicationInstallDirectory() / openstudio::toPath("share/openstudio-" + openStudioVersion()) / energyPlusDirectoryName;
#elif defined(Q_OS_MAC)
    return getApplicationRunDirectory().parent_path().parent_path().parent_path() / openstudio::toPath("sharedresources") / energyPlusDirectoryName;
#else
    return getApplicationRunDirectory().parent_path() / openstudio::toPath("share/openstudio") / energyPlusDirectoryName;
#endif
  }
}

openstudio::path getEnergyPlusExecutable() {
  openstudio::path cmakeEnergyPlusPath = openstudio::toPath("${ENERGYPLUS_EXE}");
  openstudio::path energyPlusFileName = cmakeEnergyPlusPath.filename();

#ifdef Q_OS_LINUX
    return getEnergyPlusDirectory() / energyPlusFileName;
#elif defined(Q_OS_MAC)
    return getEnergyPlusDirectory() / energyPlusFileName;
#else
   return getEnergyPlusDirectory() / energyPlusFileName;
#endif
}

boost::optional<openstudio::path> getRadianceDirectory() {
  openstudio::path cmakeRadianceDirectory = openstudio::toPath("${RADIANCE_LOCATION}");
  openstudio::path radianceDirectoryName;
  if (!cmakeRadianceDirectory.empty()){
    radianceDirectoryName = cmakeRadianceDirectory.filename();
  }

  openstudio::path result;

  if (applicationIsRunningFromBuildDirectory())
  {
    result = cmakeRadianceDirectory;
  } else {
#ifdef Q_OS_LINUX
    result = getApplicationInstallDirectory() / openstudio::toPath("share/openstudio-" + openStudioVersion()) / radianceDirectoryName;
#elif defined(Q_OS_MAC)
    result = getApplicationRunDirectory().parent_path().parent_path().parent_path() / openstudio::toPath("sharedresources") / radianceDirectoryName;
#else
    result = getApplicationRunDirectory().parent_path() / openstudio::toPath("share/openstudio") / radianceDirectoryName;
#endif
  }

  if (exists(result)){
    return result;
  }

  return boost::none;
}

} // openstudio
